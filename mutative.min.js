class mutative{static#t;static#e=t=>{Object.entries(mutative.#t).forEach((([e,r])=>{t.forEach((t=>{[...Array.from(t?.addedNodes),...Array.from(t?.removedNodes),t?.target].forEach((s=>{s instanceof Element&&s.matches(e)&&r(t)}))}))}))};static#r=new MutationObserver(mutative.#e);selectorList;static addSelectorObj(t){Object.assign(mutative.#t,t)}addSelectorFnPair(t,e){const r={};r[t]=e,mutative.addSelectorObj(r),this.selectorList.push(t)}constructor(t,e){mutative.#t||(mutative.#t={},mutative.#r.observe(document.body,{attributes:!0,subtree:!0,childList:!0,characterData:!0,attributeOldValue:!0,characterDataOldValue:!0})),this.selectorList=[];const r="string"==typeof t,s=Array.isArray(t);if(!r&&!s&&"object"!=typeof t)throw new Error("selectorDict must be string, array, or object");if(r||s){if("function"!=typeof e)throw new Error("callback must be a function");s?t.forEach((t=>{this.addSelectorFnPair(t,e)})):this.addSelectorFnPair(t,e)}else{if(Object.entries(t).some((([t,e])=>"string"!=typeof t||"function"!=typeof e)))throw new Error("Must be string-function pairs");mutative.addSelectorObj(t),this.selectorList=Object.keys(t)}}disconnect=()=>{mutative.#e(mutative.#r.takeRecords()),this.selectorList.filter((t=>Object.keys(mutative.#t).includes(t))).forEach((t=>{delete mutative.#t[t]}))};toString=()=>this.selectorList.join(", ")}export default mutative;