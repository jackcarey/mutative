class Mutative{static#t=!1;static#e={};static#r=t=>{Mutative.#t&&Object.entries(Mutative.#e).forEach((([e,r])=>{t.forEach((t=>{[...Array.from(t?.addedNodes),...Array.from(t?.removedNodes),t?.target].forEach((i=>{i instanceof Element&&i.matches(e)&&r(t)}))}))}))};static#i=new MutationObserver(Mutative.#r);static#a(t){Object.assign(Mutative.#e,t)}static#s(t,e){const r={};r[t]=e,Mutative.#a(r)}static observe(t,e){if(Mutative.#t||(Mutative.#t=!0,Mutative.#i.observe(document.body,{attributes:!0,subtree:!0,childList:!0,characterData:!0,attributeOldValue:!0,characterDataOldValue:!0})),t){const r="string"==typeof t,i=Array.isArray(t);if(!r&&!i&&"object"!=typeof t)throw new Error("selectorDict must be string, array, or object");if(r||i){if("function"!=typeof e)throw new Error("callback must be a function");i?t.forEach((t=>{Mutative.#s(t,e)})):Mutative.#s(t,e)}else{if(Object.entries(t).some((([t,e])=>"string"!=typeof t||"function"!=typeof e)))throw new Error("Must be string-function pairs");Mutative.#a(t)}}}static disconnect(...t){if(Mutative.#r(Mutative.#i.takeRecords()),t){let e=[];const r=t=>{t.forEach((t=>{t&&(Array.isArray(t)?t.forEach((t=>r(t))):"string"==typeof t?e.push(t):r(Object.keys(t)))}))};r(t);const i=Object.keys(Object.create(Mutative.#e));e.filter((t=>i.includes(t))).forEach((t=>{delete Mutative.#e[t]}))}t?.length&&Object.keys(Mutative.#e)?.length||(Mutative.#t=!1,Mutative.#i.disconnect())}static takeRecords(){return Array.from(Mutative.#i.takeRecords())}static get isObserving(){return Mutative.#t}}export default Mutative;