class Mutative{static#t={};static#e=t=>{Object.entries(Mutative.#t).forEach((([e,r])=>{t.forEach((t=>{[...Array.from(t?.addedNodes),...Array.from(t?.removedNodes),t?.target].forEach((a=>{a instanceof Element&&a.matches(e)&&r(t)}))}))}))};static#r=new MutationObserver(Mutative.#e);static#a(t){Object.assign(Mutative.#t,t)}static#o(t,e){const r={};r[t]=e,Mutative.#a(r)}static observe(t,e){Mutative.#t||Mutative.#r.observe(document.body,{attributes:!0,subtree:!0,childList:!0,characterData:!0,attributeOldValue:!0,characterDataOldValue:!0});const r="string"==typeof t,a=Array.isArray(t);if(!r&&!a&&"object"!=typeof t)throw new Error("selectorDict must be string, array, or object");if(r||a){if("function"!=typeof e)throw new Error("callback must be a function");a?t.forEach((t=>{Mutative.#o(t,e)})):Mutative.#o(t,e)}else{if(Object.entries(t).some((([t,e])=>"string"!=typeof t||"function"!=typeof e)))throw new Error("Must be string-function pairs");Mutative.#a(t)}}static disconnect(...t){if(Mutative.#e(Mutative.#r.takeRecords()),t?.length){let e=[];const r=t=>{t.forEach((t=>{Array.isArray(t)?t.forEach((t=>r(t))):"string"==typeof t?e.push(t):Object.keys(t).forEach((t=>e.push(t)))}))};r(t),e.filter((t=>Object.keys(Mutative.#t).includes(t))).forEach((t=>{delete Mutative.#t[t]}))}else Mutative.#r.disconnect()}static takeRecords(){return Array.from(Mutative.#r.takeRecords())}}export default Mutative;